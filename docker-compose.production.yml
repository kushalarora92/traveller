version: '3.7'

services:
  # client:
  #   image: ${PROJECT}-client:dev
  #   container_name: ${PROJECT}-client
  #   build:
  #     context: ./client
  #     dockerfile: .docker/Dockerfile.prod
  #   restart: always
  #   ports:
  #     - '$CLIENT_PORT:$CLIENT_PORT'
  #   volumes:
  #     # Binds the application folder from the host inside the container for fast changes
  #     - ./client:/usr/src/app/
  #     # Ignores/Hides the node_modules from the bind on the host allowing the node_modules
  #     # from inside the container to be used instead
  #     - /usr/src/app/node_modules
  #   environment:
  #     - PORT=${CLIENT_PORT}
  #   networks:
  #     - network

  server:
    image: ${PROJECT}-server:${GIT_LOCAL_BRANCH}
    container_name: ${PROJECT}-server
    # This defines the configuration options, including the context and dockerfile,
    # that will be applied when Compose builds the application image.
    build:
      # This defines the build context for the image build — in this case, the current project directory.
      context: ./server
      # This specifies the Dockerfile in your current project directory as the file
      dockerfile: .docker/Dockerfile.prod
    networks:
      - network
    # This defines the restart policy. The default is no,
    # but we have set the container to restart unless it is stopped.
    restart: unless-stopped
    env_file: ./server/.env
    ports:
      # This maps port from .env on the host to same port number on the container.
      - '$SERVER_PORT:$SERVER_PORT'
    volumes:
      # Binds the application folder from the host inside the container for fast changes
      - ./server:/app/
      # Ignores/Hides the node_modules from the bind on the host allowing the node_modules
      # from inside the container to be used instead
      - /app/node_modules
    depends_on:
      mysql:
        condition: service_healthy

  mysql:
    image: ${PROJECT}-db:${GIT_LOCAL_BRANCH}
    container_name: ${PROJECT}-db
    build:
      context: ./database
    restart: always
    ports:
      - '$DB_PORT:$DB_PORT'
    platform: linux/x86_64
    env_file: ./server/.env
    volumes:
      # The named volume dbdata will persist the data stored in MySQL's default data directory, /var/lib/mysql.
      # This will ensure that you don’t lose data in cases where you stop or remove containers.
      - dbdata:/var/lib/mysql
      - ./database:/docker-entrypoint-initdb.d
    environment:
      - MYSQL_ROOT_PASSWORD=$DB_ROOT_PWD
      - MYSQL_USER=$DB_USERNAME
      - MYSQL_PASSWORD=$DB_PASSWORD
      - MYSQL_DATABASE=$DB_NAME
      - MYSQL_TCP_PORT=$DB_PORT
    networks:
      - network
    healthcheck:
      test:
        [
          'CMD-SHELL',
          "mysql $$MYSQL_DATABASE -u$$MYSQL_USER -p$$MYSQL_PASSWORD -e 'SELECT 1;'",
        ]
      interval: 5s
      timeout: 5s
      retries: 5

# Our top-level volumes key defines the volumes dbdata.
# When Docker creates volumes, the contents of the volume are stored in a part of the host filesystem, /var/lib/docker/volumes/, that’s managed by Docker.
# The contents of each volume are stored in a directory under /var/lib/docker/volumes/ and get mounted to any container that uses the volume.
# In this way, the data that our users will create will persist in the dbdata volume even if we remove and recreate the db container.
volumes:
  dbdata:

networks:
  network:
    driver: 'bridge'
